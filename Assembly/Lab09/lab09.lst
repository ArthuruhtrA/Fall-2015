


ARM Macro Assembler    Page 1 CMPE 250 Lab 09


    1 00000000                 TTL              CMPE 250 Lab 09
    2 00000000         ;*******************************************************
                       *********
    3 00000000         ;Descriptive comment header goes here.
    4 00000000         ;String Operations
    5 00000000         ;Name:  Ari Sanders
    6 00000000         ;Date:  <Date completed here>
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  04 Thursday at 1600-1550
    9 00000000         ;-------------------------------------------------------
                       --------
   10 00000000         ;Keil Template for KL46
   11 00000000         ;R. W. Melton
   12 00000000         ;April 3, 2015
   13 00000000         ;*******************************************************
                       *********
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;*******************************************************
                       *********
   18 00000000         ;Include files
   19 00000000                 GET              MKL46Z4.s   ;Included by start.
                                                            s
   21 00000000         ;*******************************************************
                       *********
   22 00000000         ;EQUates
   23 00000000         ;-------------------------------------------------------
                       --------
   24 00000000         ;From Professor Melton
   25 00000000         ;***********************
   26 00000000         ;Characters
   27 00000000 00000008 
                       BS      EQU              0x08
   28 00000000 0000000D 
                       CR      EQU              0x0D
   29 00000000 0000007F 
                       DEL     EQU              0x7F
   30 00000000 0000001B 
                       ESC     EQU              0x1B
   31 00000000 0000000A 
                       LF      EQU              0x0A
   32 00000000 00000000 
                       NULL    EQU              0x00
   33 00000000         ;***********************
   34 00000000         ;Strings
   35 00000000 0000004F 
                       MAX_STRING
                               EQU              79
   36 00000000         ;***********************
   37 00000000         ; Queue management record field offsets
   38 00000000 00000000 
                       IN_PTR  EQU              0
   39 00000000 00000004 
                       OUT_PTR EQU              4
   40 00000000 00000008 
                       BUF_STRT
                               EQU              8
   41 00000000 0000000C 
                       BUF_PAST



ARM Macro Assembler    Page 2 CMPE 250 Lab 09


                               EQU              12
   42 00000000 00000010 
                       BUF_SIZE
                               EQU              16
   43 00000000 00000011 
                       NUM_ENQD
                               EQU              17
   44 00000000         ; Queue structure sizes
   45 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4           ;Queue contents
   46 00000000 00000012 
                       Q_REC_SZ
                               EQU              18          ;Queue management r
                                                            ecord
   47 00000000         ; Tx/Rx Queue structure sizes
   48 00000000 00000050 
                       XQ_BUF_SZ
                               EQU              80          ;Queue contents
   49 00000000         ; Queue delimiters for printed output
   50 00000000 0000003E 
                       Q_BEGIN_CH
                               EQU              '>'
   51 00000000 0000003C 
                       Q_END_CH
                               EQU              '<'
   52 00000000         
   53 00000000         ;For Lab 09
   54 00000000         ;-------------------------------------------------------
                       --------
   55 00000000         ;NVIC_ICER
   56 00000000         ;31-00:CLRENA=masks for HW IRQ sources;
   57 00000000         ;             read:   0 = unmasked;   1 = masked
   58 00000000         ;             write:  0 = no effect;  1 = mask
   59 00000000         ;12:UART0 IRQ mask
   60 00000000 00001000 
                       NVIC_ICER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   61 00000000         ;-------------------------------------------------------
                       --------
   62 00000000         ;NVIC_ICPR
   63 00000000         ;31-00:CLRPEND=pending status for HW IRQ sources;
   64 00000000         ;             read:   0 = not pending;  1 = pending
   65 00000000         ;             write:  0 = no effect;
   66 00000000         ;                     1 = change status to not pending
   67 00000000         ;12:UART0 IRQ pending status
   68 00000000 00001000 
                       NVIC_ICPR_UART0_MASK
                               EQU              UART0_IRQ_MASK
   69 00000000         ;-------------------------------------------------------
                       --------
   70 00000000         ;NVIC_IPR0-NVIC_IPR7
   71 00000000         ;2-bit priority:  00 = highest; 11 = lowest
   72 00000000 00000003 
                       UART0_IRQ_PRIORITY
                               EQU              3
   73 00000000 000000C0 
                       NVIC_IPR_UART0_MASK
                               EQU              (3 << UART0_PRI_POS)



ARM Macro Assembler    Page 3 CMPE 250 Lab 09


   74 00000000 000000C0 
                       NVIC_IPR_UART0_PRI_3
                               EQU              (UART0_IRQ_PRIORITY << UART0_PR
I_POS)
   75 00000000         ;-------------------------------------------------------
                       --------
   76 00000000         ;NVIC_ISER
   77 00000000         ;31-00:SETENA=masks for HW IRQ sources;
   78 00000000         ;             read:   0 = masked;     1 = unmasked
   79 00000000         ;             write:  0 = no effect;  1 = unmask
   80 00000000         ;12:UART0 IRQ mask
   81 00000000 00001000 
                       NVIC_ISER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   82 00000000         ;-------------------------------------------------------
                       --------
   83 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   84 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   85 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   86 00000000         ;-------------------------------------------------------
                       --------
   87 00000000         ;Port A
   89 00000000 01000200 
                       PORT_PCR_SET_PTA1_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:       
                             PORT_PCR_MUX_SELECT_2_MASK)
   91 00000000 01000200 
                       PORT_PCR_SET_PTA2_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:       
                             PORT_PCR_MUX_SELECT_2_MASK)
   92 00000000         ;-------------------------------------------------------
                       --------
   93 00000000         ;SIM_SCGC4
   94 00000000         ;1->10:UART0 clock gate control (enabled)
   95 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   96 00000000         ;-------------------------------------------------------
                       --------
   97 00000000         ;SIM_SCGC5
   98 00000000         ;1->09:Port A clock gate control (enabled)
   99 00000000         ;Use provided SIM_SCGC5_PORTA_MASK
  100 00000000         ;-------------------------------------------------------
                       --------
  101 00000000         ;SIM_SOPT2
  102 00000000         ;01=27-26:UART0SRC=UART0 clock source select
  103 00000000         ;         (PLLFLLSEL determines MCGFLLCLK' or MCGPLLCLK/
                       2)
  104 00000000         ; 1=   16:PLLFLLSEL=PLL/FLL clock select (MCGPLLCLK/2)
  106 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGPLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
  108 00000000 04010000 
                       SIM_SOPT2_UART0_MCGPLLCLK_DIV2
                               EQU              (SIM_SOPT2_UART0SRC_MCGPLLCLK :
OR: SIM_SOPT2_PLLFLLSEL_MASK)
  109 00000000         ;-------------------------------------------------------
                       --------
  110 00000000         ;SIM_SOPT5
  111 00000000         ; 0->   16:UART0 open drain enable (disabled)
  112 00000000         ; 0->   02:UART0 receive data select (UART0_RX)



ARM Macro Assembler    Page 4 CMPE 250 Lab 09


  113 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
  117 00000000 00010007 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:  
                                SIM_SOPT5_UART0RXSRC_MASK :OR:               
                   SIM_SOPT5_UART0TXSRC_MASK)
  118 00000000         ;-------------------------------------------------------
                       --------
  119 00000000         ;UART0_BDH
  120 00000000         ;    0->  7:LIN break detect IE (disabled)
  121 00000000         ;    0->  6:RxD input active edge IE (disabled)
  122 00000000         ;    0->  5:Stop bit number select (1)
  123 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
  124 00000000         ;UART0CLK is MCGPLLCLK/2
  125 00000000         ;MCGPLLCLK is 96 MHz
  126 00000000         ;MCGPLLCLK/2 is 48 MHz
  127 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
  128 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
  129 00000000         ;-------------------------------------------------------
                       --------
  130 00000000         ;UART0_BDL
  131 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
  132 00000000         ;UART0CLK is MCGPLLCLK/2
  133 00000000         ;MCGPLLCLK is 96 MHz
  134 00000000         ;MCGPLLCLK/2 is 48 MHz
  135 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
  136 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
  137 00000000         ;-------------------------------------------------------
                       --------
  138 00000000         ;UART0_C1
  139 00000000         ;0-->7:LOOPS=loops select (normal)
  140 00000000         ;0-->6:DOZEEN=doze enable (disabled)
  141 00000000         ;0-->5:RSRC=receiver source select (internal--no effect 
                       LOOPS=0)
  142 00000000         ;0-->4:M=9- or 8-bit mode select 
  143 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
  144 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
  145 00000000         ;0-->2:IDLE=idle line type select (idle begins after sta
                       rt bit)
  146 00000000         ;0-->1:PE=parity enable (disabled)
  147 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
  148 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
  149 00000000         ;-------------------------------------------------------
                       --------
  150 00000000         ;UART0_C2
  151 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
  152 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
  153 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
  154 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
  155 00000000         ;1-->3:TE=transmitter enable (enabled)
  156 00000000         ;1-->2:RE=receiver enable (enabled)
  157 00000000         ;0-->1:RWU=receiver wakeup control (normal)
  158 00000000         ;0-->0:SBK=send break (disabled, normal)



ARM Macro Assembler    Page 5 CMPE 250 Lab 09


  159 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2
_RE_MASK)
  160 00000000 0000002C 
                       UART0_C2_T_RI
                               EQU              (UART0_C2_RIE_MASK :OR: UART0_C
2_T_R)
  161 00000000 000000AC 
                       UART0_C2_TI_RI
                               EQU              (UART0_C2_TIE_MASK :OR: UART0_C
2_T_RI)
  162 00000000         ;-------------------------------------------------------
                       --------
  163 00000000         ;UART0_C3
  164 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  165 00000000         ;           10th data bit for transmitter (not used M10=
                       0)
  166 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  167 00000000         ;           10th data bit for receiver (not used M10=0)
  168 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  169 00000000         ;            (no effect LOOPS=0)
  170 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  171 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  172 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  173 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  174 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  175 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  176 00000000         ;-------------------------------------------------------
                       --------
  177 00000000         ;UART0_C4
  178 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled
                       )
  179 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled
                       )
  180 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  181 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  182 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  183 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  184 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  185 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  186 00000000         ;-------------------------------------------------------
                       --------
  187 00000000         ;UART0_C5
  188 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  189 00000000         ;  0-->  6:Reserved; read-only; always 0
  190 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  191 00000000         ;000-->4-2:Reserved; read-only; always 0
  192 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only
                       )
  193 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
                       
  194 00000000 00000000 



ARM Macro Assembler    Page 6 CMPE 250 Lab 09


                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  195 00000000         ;-------------------------------------------------------
                       --------
  196 00000000         ;UART0_S1
  197 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
                       
  198 00000000         ;0-->6:TC=transmission complete flag; read-only
  199 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  200 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  201 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear
                       )
  202 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  203 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  204 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  205 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              0x1F
  206 00000000         ;-------------------------------------------------------
                       --------
  207 00000000         ;UART0_S2
  208 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  209 00000000         ;             write 1 to clear
  210 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear
                       )
  211 00000000         ;              write 1 to clear
  212 00000000         ;0-->5:(reserved); read-only; always 0
  213 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  214 00000000         ;0-->3:RWUID=receive wake-up idle detect
  215 00000000         ;0-->2:BRK13=break character generation length (10)
  216 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  217 00000000         ;0-->0:RAF=receiver active flag; read-only
  218 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              0xC0
  219 00000000         ;-------------------------------------------------------
                       --------
  220 00000000         ;*******************************************************
                       *********
  221 00000000                 MACRO
  222 00000000         $Label  HEXA             $Char
  223 00000000         ;*******************************************************
                       ***************
  224 00000000         ;Adjusts ASCII character in $Char for correct value on [
                       'A','F'] if 
  225 00000000         ;character is more than '9'.
  226 00000000         ;Input:   $Char:  Character to adjust for hex digit
  227 00000000         ;Output:  $Char:  Adjusted hex digit
  228 00000000         ;Modify:  PSR,$Char
  229 00000000         ;-------------------------------------------------------
                       --------
  230 00000000         ;Provided to Ari Sanders
  231 00000000         ;R. W. Melton
  232 00000000         ;October 23, 2015
  233 00000000         ;*******************************************************
                       ***************
  234 00000000                 CMP              $Char,#'9'  ;if (Digit
  235 00000000                 BLS              $Label.OK   ;         > '9') {
  236 00000000         ;  map to ['A','F']



ARM Macro Assembler    Page 7 CMPE 250 Lab 09


  237 00000000                 ADDS             $Char,$Char,#'A'
  238 00000000                 SUBS             $Char,$Char,#('9' + 1)
  239 00000000         $Label.OK                            ;}
  240 00000000                 MEND
  241 00000000         ;*******************************************************
                       *********
  242 00000000         ;Program
  243 00000000         ;Linker requires Reset_Handler
  244 00000000                 AREA             MyCode,CODE,READONLY
  245 00000000                 ENTRY
  246 00000000                 EXPORT           Reset_Handler
  247 00000000                 IMPORT           Startup
  248 00000000         Reset_Handler
  249 00000000         main
  250 00000000         ;-------------------------------------------------------
                       --------
  251 00000000         ;Mask interrupts
  252 00000000 B672            CPSID            I
  253 00000002         ;KL46 system startup with 48-MHz system clock
  254 00000002 F7FF FFFE       BL               Startup
  255 00000006         ;-------------------------------------------------------
                       --------
  256 00000006         ;>>>>> begin main program code <<<<<
  257 00000006 F000 F95D       BL               Init_UART0_IRQ ;Initialize UART
                                                            0 IRQ
  258 0000000A B662            CPSIE            I
  259 0000000C 4840            LDR              R0, =QBuffer ;Initialize progra
                                                            m queue
  260 0000000E 4941            LDR              R1, =QRecord
  261 00000010 2204            MOVS             R2, #Q_BUF_SZ
  262 00000012 F000 F94C       BL               InitQueue
  263 00000016 4840    Prompt  LDR              R0, =PromptStr ;Prompt
  264 00000018 2126            MOVS             R1, #(PromptPast - PromptStr)
  265 0000001A F000 FA0F       BL               PutStringSB
  266 0000001E F000 F8F9       BL               GetChar     ;Get input
  267 00000022         
  268 00000022 F000 F9C1       BL               PutChar     ;Output char
  269 00000026 F000 F9CB       BL               PutCRLF     ;Output CRLF
  270 0000002A         
  271 0000002A         ;Convert capitals to lowercase
  272 0000002A         ;Check if character is >= A and <= Z
  273 0000002A 2841            CMP              R0, #'A'
  274 0000002C DB03            BLT              CapsDone
  275 0000002E 285A            CMP              R0, #'Z'
  276 00000030 DC01            BGT              CapsDone
  277 00000032         ;If so, subtract A, then add a
  278 00000032 3841            SUBS             R0, R0, #'A'
  279 00000034 3061            ADDS             R0, R0, #'a'
  280 00000036         
  281 00000036 2864    CapsDone
                               CMP              R0, #'d'    ;Check for valid in
                                                            put,
  282 00000038 D008            BEQ              d           ;Then branch to pro
                                                            per code
  283 0000003A 2865            CMP              R0, #'e'
  284 0000003C D015            BEQ              e
  285 0000003E 2868            CMP              R0, #'h'
  286 00000040 D02A            BEQ              h
  287 00000042 2870            CMP              R0, #'p'



ARM Macro Assembler    Page 8 CMPE 250 Lab 09


  288 00000044 D02F            BEQ              p
  289 00000046 2873            CMP              R0, #'s'
  290 00000048 D045            BEQ              s
  291 0000004A E7E4            B                Prompt      ;Otherwise loop to 
                                                            prompt
  292 0000004C 4931    d       LDR              R1, =QRecord ;D equeue
  293 0000004E F000 F87F       BL               Dequeue
  294 00000052 D304            BCC              dcont
  295 00000054 4831            LDR              R0, =FailureStr
  296 00000056 2109            MOVS             R1, #(FailPast - FailureStr)
  297 00000058 F000 F9F0       BL               PutStringSB
  298 0000005C E03F            B                step8
  299 0000005E F000 F9A3 
                       dcont   BL               PutChar     ;Write to terminal
  300 00000062 203A            MOVS             R0, #':'
  301 00000064 F000 F9A0       BL               PutChar
  302 00000068 E039            B                step8
  303 0000006A 482D    e       LDR              R0, =EnqueueStr 
                                                            ;E nqueue (prompt)
  304 0000006C 2116            MOVS             R1, #(EnqPast - EnqueueStr)
  305 0000006E F000 F9E5       BL               PutStringSB
  306 00000072 F000 F8CF       BL               GetChar     ;Get input
  307 00000076 F000 F997       BL               PutChar
  308 0000007A F000 F9A1       BL               PutCRLF     ;Output CRLF
  309 0000007E 4925            LDR              R1, =QRecord
  310 00000080 F000 F8B2       BL               Enqueue
  311 00000084 2109            MOVS             R1, #0x9    ;Length of both Fai
                                                            lStr and StatusStr
  312 00000086 D303            BCC              e2
  313 00000088 4824            LDR              R0, =FailureStr
  314 0000008A F000 F9D7       BL               PutStringSB
  315 0000008E E026            B                step8
  316 00000090 4824    e2      LDR              R0, =SuccessStr
  317 00000092 F000 F9D3       BL               PutStringSB
  318 00000096 E022            B                step8
  319 00000098 4823    h       LDR              R0, =HelpStr ;H elp (list comma
                                                            nds)
  320 0000009A 213A            MOVS             R1, #(HelpPast - HelpStr)
  321 0000009C F000 F9CE       BL               PutStringSB
  322 000000A0 F000 F98E       BL               PutCRLF
  323 000000A4 E7B7            B                Prompt
  324 000000A6 203E    p       MOVS             R0, #Q_BEGIN_CH ;P rint queue
  325 000000A8 F000 F97E       BL               PutChar
  326 000000AC         ;Loop through queue, print each char
  327 000000AC 4919            LDR              R1, =QRecord
  328 000000AE 7C4A            LDRB             R2, [R1, #NUM_ENQD]
  329 000000B0 68CB            LDR              R3, [R1, #BUF_PAST]
  330 000000B2 684C            LDR              R4, [R1, #OUT_PTR]
  331 000000B4 2A00    Loop    CMP              R2, #0
  332 000000B6 D008            BEQ              Cont
  333 000000B8 7820            LDRB             R0, [R4, #0]
  334 000000BA F000 F975       BL               PutChar
  335 000000BE 1E52            SUBS             R2, R2, #1
  336 000000C0 1C64            ADDS             R4, R4, #1
  337 000000C2 429C            CMP              R4, R3
  338 000000C4 D3F6            BLO              Loop
  339 000000C6 688C            LDR              R4, [R1, #BUF_STRT]
  340 000000C8 E7F4            B                Loop
  341 000000CA 203C    Cont    MOVS             R0, #Q_END_CH



ARM Macro Assembler    Page 9 CMPE 250 Lab 09


  342 000000CC F000 F96C       BL               PutChar
  343 000000D0 F000 F976       BL               PutCRLF
  344 000000D4 E79F            B                Prompt
  345 000000D6         s                                    ;S tatus (InPointer
                                                            , OutPointer, Numbe
                                                            rEnqueued)
  346 000000D6 4815            LDR              R0, =StatusStr
  347 000000D8 2108            MOVS             R1, #(StatusPast - StatusStr)
  348 000000DA F000 F9AF       BL               PutStringSB
  349 000000DE         step8                                ;InStr 8, OutStr A,
                                                             NumStr 8
  350 000000DE 4A0D            LDR              R2, =QRecord
  351 000000E0         ;In
  352 000000E0 4813            LDR              R0, =InStr
  353 000000E2 2109            MOVS             R1, #(InPast - InStr)
  354 000000E4 F000 F9AA       BL               PutStringSB
  355 000000E8 6810            LDR              R0, [R2, #IN_PTR]
  356 000000EA F000 F971       BL               PutNumHex
  357 000000EE         ;Out
  358 000000EE 4811            LDR              R0, =OutStr
  359 000000F0 210A            MOVS             R1, #(OutPast - OutStr)
  360 000000F2 F000 F9A3       BL               PutStringSB
  361 000000F6 6850            LDR              R0, [R2, #OUT_PTR]
  362 000000F8 F000 F96A       BL               PutNumHex
  363 000000FC         ;Num
  364 000000FC 480E            LDR              R0, =NumStr
  365 000000FE 2108            MOVS             R1, #(NumPast - NumStr)
  366 00000100 F000 F99C       BL               PutStringSB
  367 00000104 7C50            LDRB             R0, [R2, #NUM_ENQD]
  368 00000106 F000 F993       BL               PutNumUB
  369 0000010A F000 F959       BL               PutCRLF
  370 0000010E         
  371 0000010E E782            B                Prompt      ;Loop back to promp
                                                            t
  372 00000110         ;>>>>>   end main program code <<<<<
  373 00000110 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000         LTORG
  374 00000150         ;;Stay here
  375 00000150         ;            B       .
  376 00000150         ;>>>>> begin subroutine code <<<<<
  377 00000150         ;-------------------------------------------------------
                       --------
  378 00000150         Dequeue
  379 00000150         ;*******************************************************
                       ***************



ARM Macro Assembler    Page 10 CMPE 250 Lab 09


  380 00000150         ; Dequeues a character to R0 from queue referenced by R1
                       .
  381 00000150         ; Sets/clears CCR bit C to reflect failure/success of de
                       queue.
  382 00000150         ; Input:   R1: Address of queue management record struct
                       ure
  383 00000150         ; Output:  R0: Character dequeued
  384 00000150         ;          PSR.C = (Boolean) Failure
  385 00000150         ; Modify:  R0, PSR
  386 00000150         ;-------------------------------------------------------
                       --------
  387 00000150         ;Provided to Ari Sanders
  388 00000150         ;R. W. Melton
  389 00000150         ;October 23, 2015
  390 00000150         ;*******************************************************
                       ***************
  391 00000150         ;Save registers
  392 00000150 B40C            PUSH             {R2-R3}
  393 00000152         ;Dequeue
  394 00000152 7C4A            LDRB             R2,[R1,#NUM_ENQD] 
                                                            ;check queue count
  395 00000154 2A00            CMP              R2,#0       ;if (queue not empt
                                                            y) {
  396 00000156 D00C            BEQ              DequeueFail
  397 00000158 684B            LDR              R3,[R1,#OUT_PTR] ;  get address
                                                             of character
  398 0000015A 7818            LDRB             R0,[R3,#0]  ;  dequeue characte
                                                            r
  399 0000015C 1C5B            ADDS             R3,R3,#1    ;  OutPointer++
  400 0000015E 1E52            SUBS             R2,R2,#1    ;  NumberEnqueued--
                                                            
  401 00000160 744A            STRB             R2,[R1,#NUM_ENQD]
  402 00000162 68CA            LDR              R2,[R1,#BUF_PAST] ;  if (OutPoi
                                                            nter past buffer) {
                                                            
  403 00000164 4293            CMP              R3,R2
  404 00000166 D300            BLO              DequeueOutPtr
  405 00000168 688B            LDR              R3,[R1,#BUF_STRT] ;    adjust t
                                                            o start of buffer
  406 0000016A         DequeueOutPtr                        ;  }end if (OutPoin
                                                            ter)
  407 0000016A 604B            STR              R3,[R1,#OUT_PTR] ;  store updat
                                                            ed OutPointer
  408 0000016C 2200            MOVS             R2,#0       ;  clear C flag (re
                                                            port successful)
  409 0000016E 0852            LSRS             R2,R2,#1
  410 00000170 E001            B                DequeueDone ;}end if (queue)
  411 00000172         DequeueFail                          ;else { ;nothing to
                                                             dequeue
  412 00000172 2201            MOVS             R2,#1       ;  set C flag (repo
                                                            rt failure)
  413 00000174 0852            LSRS             R2,R2,#1    ;}end else
  414 00000176         DequeueDone
  415 00000176         ;Restore registers
  416 00000176 BC0C            POP              {R2-R3}
  417 00000178 4770            BX               LR
  418 0000017A         ;-------------------------------------------------------
                       --------
  419 0000017A         DIVU



ARM Macro Assembler    Page 11 CMPE 250 Lab 09


  420 0000017A         ;*******************************************************
                       ***************
  421 0000017A         ;Divide unsigned
  422 0000017A         ;Divides R1 by R0 and returns the quotient in R0 and the
                        remainder in
  423 0000017A         ;R1.  If divide by 0, R0 and R1 are unchanged, and C bit
                        of APSR is set.
  424 0000017A         ;Otherwise, C bit of APSR is clear.
  425 0000017A         ;Input:  R0:  Divisor
  426 0000017A         ;        R1:  Dividend
  427 0000017A         ;Output:  R0:  Quotient
  428 0000017A         ;         R1:  Remainder
  429 0000017A         ;         C:   1 if divide by 0; 0 otherwise
  430 0000017A         ;Modify:  R0,R1,APSR
  431 0000017A         ;-------------------------------------------------------
                       --------
  432 0000017A         ;Provided to Ari Sanders
  433 0000017A         ;R. W. Melton
  434 0000017A         ;October 23, 2015
  435 0000017A         ;*******************************************************
                       ***************
  436 0000017A         ;Other registers used
  437 0000017A         ;R2:Bit mask
  438 0000017A         ;R3:Counter
  439 0000017A         ;R4:Quotient
  440 0000017A B41C            PUSH             {R2-R4}     ;Save temporary reg
                                                            isters
  441 0000017C 2201            MOVS             R2,#1       ;Mask_MSB = 0x80000
                                                            00
  442 0000017E 07D2            LSLS             R2,R2,#31
  443 00000180 2400            MOVS             R4,#0       ;Quotient != 0
  444 00000182 2800            CMP              R0,#0       ;if (Divisor  != 0)
                                                            {
  445 00000184 D022            BEQ              DIVU_Done   ;//C was set if R0 
                                                            == 0
  446 00000186 2900            CMP              R1,#0       ;  if (Dividend != 
                                                            0) {
  447 00000188 D022            BEQ              DIVU_0R0
  448 0000018A 2801            CMP              R0,#1       ;    if (Divisor !=
                                                             1) {
  449 0000018C D022            BEQ              DIVU_By1
  450 0000018E 4288            CMP              R0,R1       ;      if (Divisor 
                                                            <= Dividend) {
  451 00000190 D822            BHI              DIVU_0
  452 00000192 2201            MOVS             R2,#1       ;        Mask_MSB =
                                                             0x8000000
  453 00000194 07D2            LSLS             R2,R2,#31
  454 00000196 2300            MOVS             R3,#0       ;        DivisorAli
                                                            gn = 0
  455 00000198         DIVU_Align                           ;        repeat {
  456 00000198 1C5B            ADDS             R3,R3,#1    ;          DivisorA
                                                            lign++
  457 0000019A 0040            LSLS             R0,R0,#1    ;          Divisor 
                                                            <<= 1
  458 0000019C         ;        until ((significant bit shifted out)
  459 0000019C D21D            BCS              DIVU_Restore
  460 0000019E 4288            CMP              R0,R1       ;                ||
                                                             (R0 >= R1))
  461 000001A0 D3FA            BLO              DIVU_Align



ARM Macro Assembler    Page 12 CMPE 250 Lab 09


  462 000001A2         ;        if (R0 = R1) {
  463 000001A2 D01E            BEQ              DIVU_1R0
  464 000001A4         ;           Result is 1<<DivisorAlign Rem 0
  465 000001A4         ;        }
  466 000001A4         ;        else {
  467 000001A4 1E5B            SUBS             R3,R3,#1    ;          DivisorA
                                                            lgin--
  468 000001A6 0840            LSRS             R0,R0,#1    ;          Restore 
                                                            divisor from last s
                                                            hift
  469 000001A8         ;        }
  470 000001A8         DIVU_Subtract                        ;        repeat {
  471 000001A8 4281            CMP              R1,R0       ;          if (Divi
                                                            dend > Divisor) {
  472 000001AA D305            BLO              DIVU_Subtract_None
  473 000001AC 1E5B            SUBS             R3,R3,#1    ;            Diviso
                                                            rAlign--    
  474 000001AE 1A09            SUBS             R1,R1,R0    ;            Divide
                                                            nd -= Divisor
  475 000001B0 0064            LSLS             R4,R4,#1    ;            Quotie
                                                            nt = (Quotient << 1
                                                            ) + 1
  476 000001B2 1C64            ADDS             R4,R4,#1    ;
  477 000001B4 0840            LSRS             R0,R0,#1    ;            Diviso
                                                            r >>= 1
  478 000001B6 E002            B                DIVU_Subtract_EndIf
  479 000001B8         DIVU_Subtract_None                   ;          } else {
                                                            
  480 000001B8 1E5B            SUBS             R3,R3,#1    ;            Diviso
                                                            rAlign--
  481 000001BA 0064            LSLS             R4,R4,#1    ;            Quotie
                                                            nt = (Quotient << 1
                                                            )
  482 000001BC 0840            LSRS             R0,R0,#1    ;            Diviso
                                                            r >>= 1
  483 000001BE         DIVU_Subtract_EndIf                  ;          }
  484 000001BE 2B00            CMP              R3,#0       ;        } until (D
                                                            ivisorAlign < 0) {
  485 000001C0 DB01            BLT              DIVU_Quotient
  486 000001C2 E7F1            B                DIVU_Subtract
  487 000001C4         ;      } if (Divisor <= Dividend)
  488 000001C4         ;    } if (Dividend != 1)
  489 000001C4         ;  } if (Dividend != 0)
  490 000001C4         ;} if (Divisor != 0)
  491 000001C4 409C    DIVU_Adjust
                               LSLS             R4,R4,R3    ;Quotient <<= Divis
                                                            orAlign           
  492 000001C6         DIVU_Quotient
  493 000001C6 2000            MOVS             R0,#0       ;Clear carry to rep
                                                            ort success
  494 000001C8 0040            LSLS             R0,R0,#1
  495 000001CA 4320            ORRS             R0,R4       ;Move quotient to R
                                                            0, setting Z and V
  496 000001CC BC1C    DIVU_Done
                               POP              {R2-R4}
  497 000001CE 4770            BX               LR
  498 000001D0 2100    DIVU_0R0
                               MOVS             R1,#0
  499 000001D2 E7F8            B                DIVU_Quotient



ARM Macro Assembler    Page 13 CMPE 250 Lab 09


  500 000001D4 000C    DIVU_By1
                               MOVS             R4,R1
  501 000001D6 2100            MOVS             R1,#0
  502 000001D8 E7F5    DIVU_0  B                DIVU_Quotient
  503 000001DA         DIVU_Restore                         ;Dividend MSb was s
                                                            hifted out
  504 000001DA 1E5B            SUBS             R3,R3,#1    ;DivisorAlgin--
  505 000001DC 0840            LSRS             R0,R0,#1    ;Restore divisor fr
                                                            om last shift
  506 000001DE 4310            ORRS             R0,R0,R2    ;
  507 000001E0 E7E2            B                DIVU_Subtract
  508 000001E2 2401    DIVU_1R0
                               MOVS             R4,#1
  509 000001E4 2100            MOVS             R1,#0
  510 000001E6 E7ED            B                DIVU_Adjust
  511 000001E8         ;-------------------------------------------------------
                       --------
  512 000001E8         Enqueue
  513 000001E8         ;*******************************************************
                       ***************
  514 000001E8         ; Enqueue character from R0.
  515 000001E8         ; Sets/clears CCR bit C to reflect failure/success of de
                       queue.
  516 000001E8         ; Input:   R0: Character to enqueue
  517 000001E8         ;          R1: Address of queue management record struct
                       ure
  518 000001E8         ; Output:  CCR.C = (Boolean) Failure
  519 000001E8         ; Modify:  CCR
  520 000001E8         ;-------------------------------------------------------
                       --------
  521 000001E8         ;Provided to Ari Sanders
  522 000001E8         ;R. W. Melton
  523 000001E8         ;October 23, 2015
  524 000001E8         ;-------------------------------------------------------
                       --------
  525 000001E8         ;Provided to Ari Sanders
  526 000001E8         ;R. W. Melton
  527 000001E8         ;October 23, 2015
  528 000001E8         ;*******************************************************
                       ***************
  529 000001E8         ;Save registers
  530 000001E8 B40C            PUSH             {R2-R3}
  531 000001EA         ;Enqueue
  532 000001EA 7C4A            LDRB             R2,[R1,#NUM_ENQD] 
                                                            ;check queue count
  533 000001EC 7C0B            LDRB             R3,[R1,#BUF_SIZE] ;against queu
                                                            e capacity
  534 000001EE 429A            CMP              R2,R3       ;if queue not full
  535 000001F0 D20C            BHS              EnqueueFail
  536 000001F2 680B            LDR              R3,[R1,#IN_PTR] ;  address for 
                                                            character
  537 000001F4 7018            STRB             R0,[R3,#0]  ;  enqueue characte
                                                            r
  538 000001F6 1C5B            ADDS             R3,R3,#1    ;  InPointer++
  539 000001F8 1C52            ADDS             R2,R2,#1    ;  NumberEnqueued++
                                                            
  540 000001FA 744A            STRB             R2,[R1,#NUM_ENQD]
  541 000001FC 68CA            LDR              R2,[R1,#BUF_PAST] ;  if (InPoin
                                                            ter past buffer) {



ARM Macro Assembler    Page 14 CMPE 250 Lab 09


  542 000001FE 4293            CMP              R3,R2
  543 00000200 D300            BLO              EnqueueInPtr
  544 00000202 688B            LDR              R3,[R1,#BUF_STRT] ;    adjust t
                                                            o start of buffer
  545 00000204         EnqueueInPtr                         ;  }end if (InPoint
                                                            er)
  546 00000204 600B            STR              R3,[R1,#IN_PTR] ;  store update
                                                            d InPointer
  547 00000206 2200            MOVS             R2,#0       ;  clear C flag (re
                                                            port successful)
  548 00000208 0852            LSRS             R2,R2,#1
  549 0000020A E001            B                EnqueueDone ;}end if (queue)
  550 0000020C         EnqueueFail                          ;else {;no room in 
                                                            queue
  551 0000020C 2201            MOVS             R2,#1       ;  set C flag (repo
                                                            rt failure)
  552 0000020E 0852            LSRS             R2,R2,#1    ;}end else
  553 00000210         EnqueueDone
  554 00000210         ;Restore registers
  555 00000210 BC0C            POP              {R2-R3}
  556 00000212 4770            BX               LR
  557 00000214         ;-------------------------------------------------------
                       --------
  558 00000214         GetChar
  559 00000214         ;*******************************************************
                       ***************
  560 00000214         ;Get character:
  561 00000214         ;Receives the next character from the receive queue.
  562 00000214         ;Output:  R0: Character received
  563 00000214         ;Modifies:  R0, PSR
  564 00000214         ;-------------------------------------------------------
                       --------
  565 00000214         ; Wait until receiver is ready
  566 00000214 B502            PUSH             {R1, LR}    ;Save temporary reg
                                                            isters
  567 00000216 4991            LDR              R1,=RxQRecord ;R1 = Receive Que
                                                            ue address
  568 00000218 B672    GetCharLoop
                               CPSID            I
  569 0000021A F7FF FF99       BL               Dequeue     ;Receive character 
                                                            from the queue
  570 0000021E B662            CPSIE            I
  571 00000220 D2FA            BCS              GetCharLoop
  572 00000222 BD02            POP              {R1, PC}    ;Restore R1
  573 00000224 4770            BX               LR          ;Return
  574 00000226         ;-------------------------------------------------------
                       --------
  575 00000226         GetStringSB
  576 00000226         ;*******************************************************
                       ***************
  577 00000226         ;Get string in secure buffer:
  578 00000226         ;Receives each character in string from GetChar and adds
                        NULL 
  579 00000226         ;termination, preventing buffer overrun for buffer size 
                       specified.  
  580 00000226         ;Input of CR (from pressing "Enter" key) terminates inpu
                       t.  
  581 00000226         ;Handles backspace (BS) control code, but all other cont
                       rol 



ARM Macro Assembler    Page 15 CMPE 250 Lab 09


  582 00000226         ;codes and escape sequences are ignored.
  583 00000226         ;NOTE:  PuTTY Terminal->Keyboard options may need to be 
                       changed for BS
  584 00000226         ;       to work; needs to be Control-H instead of Contro
                       l-?.
  585 00000226         ;Calls:  GetChar
  586 00000226         ;        PutChar
  587 00000226         ;Input:  R0: Address of string buffer
  588 00000226         ;        R1: Capacity of string buffer
  589 00000226         ;Modifies:  PSR
  590 00000226         ;-------------------------------------------------------
                       --------
  591 00000226         ;Provided to Ari Sanders
  592 00000226         ;R. W. Melton
  593 00000226         ;October 23, 2015
  594 00000226         ;*******************************************************
                       ***************
  595 00000226 B50F            PUSH             {R0-R3,LR}  ;save registers mod
                                                            ified
  596 00000228         ;Register map
  597 00000228         ;R0:  current string character
  598 00000228         ;R1:  size of memory buffer (input parameter)
  599 00000228         ;R2:  current string index or character count
  600 00000228         ;R3:  address of string (from input parameter R0)
  601 00000228 2900            CMP              R1,#0       ;if (buffer capacit
                                                            y) {
  602 0000022A D03B            BEQ              GetStringSBNull
  603 0000022C 4603            MOV              R3,R0       ;  base address of 
                                                            string
  604 0000022E 2200            MOVS             R2,#0       ;  character count
  605 00000230 1E49            SUBS             R1,R1,#1    ;  maximum characte
                                                            rs
  606 00000232 D011            BEQ              GetStringSBFull ;  while (avail
                                                            able buffer space) 
                                                            {
  607 00000234         GetStringSBChar
  608 00000234 F7FF FFEE       BL               GetChar     ;    receive charac
                                                            ter
  609 00000238         GetStringSBCharInspect
  610 00000238 281B            CMP              R0,#ESC     ;    if escape
  611 0000023A D027            BEQ              GetStringSBESC ;      may be es
                                                            cape sequence
  612 0000023C 2808            CMP              R0,#BS      ;    elseif backspa
                                                            ce
  613 0000023E D019            BEQ              GetStringSBBS ;      evaluate p
                                                            osition
  614 00000240 280D            CMP              R0,#CR      ;    elseif CR
  615 00000242         ;      done 
  616 00000242 D00F            BEQ              GetStringSBTerminate
  617 00000244 2820            CMP              R0,#' '     ;    elseif other c
                                                            ontrol character
  618 00000246 D3F5            BLO              GetStringSBChar ;      ignore
  619 00000248 287F            CMP              R0,#DEL
  620 0000024A D0F3            BEQ              GetStringSBChar ;    else {
  621 0000024C F000 F8AC       BL               PutChar     ;      echo charact
                                                            er
  622 00000250 5498            STRB             R0,[R3,R2]  ;      store in str
                                                            ing
  623 00000252 1C52            ADDS             R2,R2,#1    ;      character co



ARM Macro Assembler    Page 16 CMPE 250 Lab 09


                                                            unt ++
  624 00000254 428A            CMP              R2,R1       ;    }end else
  625 00000256 D3ED            BLO              GetStringSBChar ;  }end while (
                                                            available buffer sp
                                                            ace)
  626 00000258         GetStringSBFull                      ;  repeat { ;with n
                                                            o available space
  627 00000258 F7FF FFDC       BL               GetChar     ;    receive charac
                                                            ter
  628 0000025C 2808            CMP              R0,#BS      ;    if backspace
  629 0000025E D009            BEQ              GetStringSBBS ;      evaluate p
                                                            osition            
                                                            
  630 00000260 280D            CMP              R0,#CR
  631 00000262 D1F9            BNE              GetStringSBFull ;  } until CR r
                                                            eceived
  632 00000264         GetStringSBTerminate                 ;}end if (buffer ca
                                                            pacity)
  633 00000264 2100            MOVS             R1,#NULL    ;terminate with NUL
                                                            L
  634 00000266 5499            STRB             R1,[R3,R2]
  635 00000268         GetStringSBDone
  636 00000268 F000 F89E       BL               PutChar     ;echo CR
  637 0000026C 200A            MOVS             R0,#LF      ;print LF
  638 0000026E F000 F89B       BL               PutChar
  639 00000272 BD0F            POP              {R0-R3,PC}  ;restore registers 
                                                            and return
  640 00000274         GetStringSBBS
  641 00000274 2A00            CMP              R2,#0       ;if (not at start o
                                                            f string) {
  642 00000276 D0DD            BEQ              GetStringSBChar
  643 00000278 F000 F896       BL               PutChar     ;  echo backspace
  644 0000027C 1E52            SUBS             R2,R2,#1    ;  character count 
                                                             --
  645 0000027E 2020            MOVS             R0,#' '     ;  overwrite with s
                                                            pace
  646 00000280 F000 F892       BL               PutChar
  647 00000284 2008            MOVS             R0,#BS      ;  back space
  648 00000286 F000 F88F       BL               PutChar
  649 0000028A E7D3            B                GetStringSBChar
  650 0000028C         ;}end if and resume while
  651 0000028C         GetStringSBESC
  652 0000028C 2401            MOVS             R4,#1       ;may be first of es
                                                            cape sequence
  653 0000028E F7FF FFC1       BL               GetChar     ;if (next character
                                                             == '[') {
  654 00000292 285B            CMP              R0,#'['
  655 00000294 D1D0            BNE              GetStringSBCharInspect
  656 00000296 287E            CMP              R0,#'~'     ;  if (not end of s
                                                            equnece) {
  657 00000298 D0CC            BEQ              GetStringSBChar
  658 0000029A         GetStringSBESCNext                   ;    repeat {
  659 0000029A F7FF FFBB       BL               GetChar     ;      consume next
                                                             in sequence
  660 0000029E 287E            CMP              R0,#'~'
  661 000002A0 D1FB            BNE              GetStringSBESCNext
  662 000002A2 E7C7            B                GetStringSBChar ;    } until (l
                                                            ast consumed)
  663 000002A4         ;  } if (not end of sequence)



ARM Macro Assembler    Page 17 CMPE 250 Lab 09


  664 000002A4         ;} if (next character == "[")
  665 000002A4         GetStringSBNull                      ;repeat {
  666 000002A4 F7FF FFB6       BL               GetChar     ;  receive characte
                                                            r
  667 000002A8 280D            CMP              R0,#CR
  668 000002AA D1FB            BNE              GetStringSBNull
  669 000002AC         ;} until CR received
  670 000002AC E7DC            B                GetStringSBDone
  671 000002AE         ;-------------------------------------------------------
                       --------
  672 000002AE         InitQueue
  673 000002AE         ;*******************************************************
                       ***************
  674 000002AE         ; Initializes FIFO queue management record structure whe
                       re R1 points
  675 000002AE         ; for byte queue buffer where R0 points and whose size i
                       s in R2.
  676 000002AE         ; Input:  R0:  Address of queue buffer
  677 000002AE         ;         R1:  Address of queue record
  678 000002AE         ;         R2:  Capacity of queue buffer in bytes
  679 000002AE         ; Output:  None
  680 000002AE         ; Modifies:  PSR
  681 000002AE         ;-------------------------------------------------------
                       --------
  682 000002AE         ;Provided to Ari Sanders
  683 000002AE         ;R. W. Melton
  684 000002AE         ;October 23, 2015
  685 000002AE         ;*******************************************************
                       ***************
  686 000002AE B401            PUSH             {R0}
  687 000002B0 6008            STR              R0,[R1,#IN_PTR]
  688 000002B2 6048            STR              R0,[R1,#OUT_PTR]
  689 000002B4 6088            STR              R0,[R1,#BUF_STRT]
  690 000002B6 1880            ADDS             R0,R0,R2
  691 000002B8 60C8            STR              R0,[R1,#BUF_PAST]
  692 000002BA 740A            STRB             R2,[R1,#BUF_SIZE]
  693 000002BC 2000            MOVS             R0,#0
  694 000002BE 7448            STRB             R0,[R1,#NUM_ENQD]
  695 000002C0 BC01            POP              {R0}
  696 000002C2 4770            BX               LR
  697 000002C4         ;-------------------------------------------------------
                       --------
  698 000002C4         Init_UART0_IRQ
  699 000002C4         ;*******************************************************
                       ***************
  700 000002C4         ;Initialize UART0 for interrupts:
  701 000002C4         ;Initializes UART0 for interrupts with 9600 baud and 8N1
                        format
  702 000002C4         ;Assumes 48-MHz core clock.
  703 000002C4         ;Uses OpenSDA USB serial port connection through PTA1 an
                       d PTA2
  704 000002C4         ;Input:  None
  705 000002C4         ;Output:  None
  706 000002C4         ;Modifies:  PSR
  707 000002C4         ;-------------------------------------------------------
                       --------
  708 000002C4 B50F            PUSH             {R0-R3, LR} ;Save registers 
  709 000002C6         
  710 000002C6 4866            LDR              R0, =TxQBuffer



ARM Macro Assembler    Page 18 CMPE 250 Lab 09


  711 000002C8 4966            LDR              R1, =TxQRecord
  712 000002CA 2250            MOVS             R2, #0x50
  713 000002CC F7FF FFEF       BL               InitQueue
  714 000002D0         
  715 000002D0 4865            LDR              R0, =RxQBuffer
  716 000002D2 4962            LDR              R1, =RxQRecord
  717 000002D4 2250            MOVS             R2, #0x50
  718 000002D6 F7FF FFEA       BL               InitQueue
  719 000002DA         
  720 000002DA         ;Select MCGPLLCLK / 2 as UART0 clock source
  721 000002DA 4865            LDR              R0,=SIM_SOPT2
  722 000002DC 4965            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  723 000002DE 6802            LDR              R2,[R0,#0]
  724 000002E0 438A            BICS             R2,R2,R1
  725 000002E2 4965            LDR              R1,=SIM_SOPT2_UART0_MCGPLLCLK_D
IV2
  726 000002E4 430A            ORRS             R2,R2,R1
  727 000002E6 6002            STR              R2,[R0,#0]
  728 000002E8         ;Set UART0 for external connection
  729 000002E8 4864            LDR              R0,=SIM_SOPT5
  730 000002EA 4965            LDR              R1,=SIM_SOPT5_UART0_EXTERN_MASK
_CLEAR
  731 000002EC 6802            LDR              R2,[R0,#0]
  732 000002EE 438A            BICS             R2,R2,R1
  733 000002F0 6002            STR              R2,[R0,#0]
  734 000002F2         ;Enable UART0 module clock
  735 000002F2 4864            LDR              R0,=SIM_SCGC4
  736 000002F4 4964            LDR              R1,=SIM_SCGC4_UART0_MASK
  737 000002F6 6802            LDR              R2,[R0,#0]
  738 000002F8 430A            ORRS             R2,R2,R1
  739 000002FA 6002            STR              R2,[R0,#0]
  740 000002FC         ;Enable PORT A module clock
  741 000002FC 4863            LDR              R0,=SIM_SCGC5
  742 000002FE 4964            LDR              R1,=SIM_SCGC5_PORTA_MASK
  743 00000300 6802            LDR              R2,[R0,#0]
  744 00000302 430A            ORRS             R2,R2,R1
  745 00000304 6002            STR              R2,[R0,#0]
  746 00000306         ;Select PORT A Pin 1 (J1 Pin 02) for UART0 RX
  747 00000306 4863            LDR              R0,=PORTA_PCR1
  748 00000308 4963            LDR              R1,=PORT_PCR_SET_PTA1_UART0_RX
  749 0000030A 6001            STR              R1,[R0,#0]
  750 0000030C         ;Select PORT A Pin 2 (J1 Pin 04) for UART0 TX
  751 0000030C 4863            LDR              R0,=PORTA_PCR2
  752 0000030E 4962            LDR              R1,=PORT_PCR_SET_PTA2_UART0_TX
  753 00000310 6001            STR              R1,[R0,#0]
  754 00000312         
  755 00000312         ;Disable UART0
  756 00000312 4863            LDR              R0,=UART0_BASE
  757 00000314 210C            MOVS             R1,#UART0_C2_T_R
  758 00000316 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  759 00000318 438A            BICS             R2,R2,R1
  760 0000031A 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  761 0000031C         
  762 0000031C         ;Set UART0 IRQ priority
  763 0000031C 4861            LDR              R0, =UART0_IPR
  764 0000031E         ;LDR R1, =NVIC_IPR_UART0_MASK
  765 0000031E 4A62            LDR              R2, =NVIC_IPR_UART0_PRI_3
  766 00000320 6803            LDR              R3, [R0, #0]
  767 00000322         ;BICS R3, R3, R1



ARM Macro Assembler    Page 19 CMPE 250 Lab 09


  768 00000322 4313            ORRS             R3, R3, R2
  769 00000324 6003            STR              R3, [R0, #0]
  770 00000326         ;Clear any pending UART0 interrupts
  771 00000326 4861            LDR              R0, =NVIC_ICPR
  772 00000328 4961            LDR              R1, =NVIC_ICPR_UART0_MASK
  773 0000032A 6001            STR              R1, [R0, #0]
  774 0000032C         ;Unmask UART0_interruprs
  775 0000032C 4861            LDR              R0, =NVIC_ISER
  776 0000032E 4960            LDR              R1, =NVIC_ISER_UART0_MASK
  777 00000330 6001            STR              R1, [R0, #0]
  778 00000332         
  779 00000332 485B            LDR              R0, =UART0_BASE
  780 00000334         ;Set for 9600 baud from 96MHz PLL clock
  781 00000334 2101            MOVS             R1,#UART0_BDH_9600
  782 00000336 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  783 00000338 2138            MOVS             R1,#UART0_BDL_9600
  784 0000033A 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  785 0000033C 2100            MOVS             R1,#UART0_C1_8N1
  786 0000033E 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  787 00000340 2100            MOVS             R1,#UART0_C3_NO_TXINV
  788 00000342 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  789 00000344 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  790 00000346 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  791 00000348 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  792 0000034A 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  793 0000034C 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  794 0000034E 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  795 00000350 21C0            MOVS             R1,#UART0_S2_NO_RXINV_BRK10_NO_
LBKDETECT_CLEAR_FLAGS
  796 00000352 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  797 00000354 212C            MOVS             R1,#UART0_C2_T_RI
  798 00000356 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  799 00000358         
  800 00000358 BD0F            POP              {R0-R3, PC} ;Return registers
  801 0000035A 4770            BX               LR          ;Return
  802 0000035C         ;-------------------------------------------------------
                       --------
  803 0000035C         UART0_ISR
  804 0000035C         ;*******************************************************
                       ***************
  805 0000035C         ;Interrupt service routine
  806 0000035C         ;Checks the type of interrupt, then acts on it
  807 0000035C         ;Transmit interrupt transmits next item in queue
  808 0000035C         ;Receive interrupt receives next item to queue
  809 0000035C         ;-------------------------------------------------------
                       --------
  810 0000035C B50F            PUSH             {R0-R3, LR} ;Save registers 
  811 0000035E 4A50            LDR              R2, =UART0_BASE ;Get UART0 Base
                                                             address
  812 00000360 7911            LDRB             R1, [R2, #UART0_S1_OFFSET] 
                                                            ;Load S1
  813 00000362 2020            MOVS             R0, #UART0_S1_RDRF_MASK 
                                                            ;Determine if RDRF
  814 00000364 000B            MOVS             R3, R1
  815 00000366 4001            ANDS             R1, R1, R0
  816 00000368 D103            BNE              ISR_Rx      ;If so, Receive
  817 0000036A 2080            MOVS             R0, #UART0_S1_TDRE_MASK ;Otherw
                                                            ise check TDRE
  818 0000036C 4003            ANDS             R3, R3, R0



ARM Macro Assembler    Page 20 CMPE 250 Lab 09


  819 0000036E D105            BNE              ISR_Tx      ;If so, Transmit
  820 00000370 E00C            B                ISR_End     ;Otherwise finish
  821 00000372 79D0    ISR_Rx  LDRB             R0, [R2, #UART0_D_OFFSET] 
                                                            ;Load D
  822 00000374 4939            LDR              R1, =RxQRecord ;Put D in Receiv
                                                            e Buffer
  823 00000376 F7FF FF37       BL               Enqueue
  824 0000037A E007            B                ISR_End     ;Finish
  825 0000037C 4939    ISR_Tx  LDR              R1, =TxQRecord ;Read next in Tr
                                                            ansmit Buffer
  826 0000037E F7FF FEE7       BL               Dequeue
  827 00000382 D302            BCC              ISR_TxS     ;If successful, tra
                                                            nsmit
  828 00000384 212C            MOVS             R1, #UART0_C2_T_RI ;Disable Tra
                                                            nsmit interrupts
  829 00000386 70D1            STRB             R1, [R2, #UART0_C2_OFFSET]
  830 00000388 E000            B                ISR_End     ;Finish
  831 0000038A 71D0    ISR_TxS STRB             R0, [R2, #UART_D_OFFSET] ;Write
                                                             to UART0_D_OFFSET
  832 0000038C BD0F    ISR_End POP              {R0-R3, PC} ;Restore registers
  833 0000038E 4770            BX               LR          ;Return
  834 00000390         ;-------------------------------------------------------
                       --------
  835 00000390         LengthStringSB
  836 00000390         ;*******************************************************
                       ***************
  837 00000390         ;Length of string in secure buffer
  838 00000390         ;Determines length of NULL-terminated string where R0 po
                       ints.
  839 00000390         ;Prevents buffer overrun for buffer size specified.
  840 00000390         ;Input:  R0: Address of string buffer
  841 00000390         ;        R1: Capacity of string buffer  
  842 00000390         ;Output:  R2:  Length of string 
  843 00000390         ;Modifies:  R1,PSR
  844 00000390         ;-------------------------------------------------------
                       --------
  845 00000390         ;Provided to Ari Sanders
  846 00000390         ;R. W. Melton
  847 00000390         ;October 23, 2015
  848 00000390         ;*******************************************************
                       ***************
  849 00000390 B408            PUSH             {R3}
  850 00000392 2200            MOVS             R2,#0       ;Length = 0
  851 00000394 2900            CMP              R1,#0       ;if (buffer capacit
                                                            y) {
  852 00000396 D005            BEQ              LengthStringSBDone
  853 00000398         LengthStringSBDo                     ;  do {
  854 00000398 5C83            LDRB             R3,[R0,R2]  ;    if (String[Len
                                                            gth] != NULL) {
  855 0000039A 2B00            CMP              R3,#NULL
  856 0000039C D002            BEQ              LengthStringSBDone
  857 0000039E 1C52            ADDS             R2,R2,#1    ;      Length++
  858 000003A0 428A            CMP              R2,R1
  859 000003A2 D3F9            BLO              LengthStringSBDo
  860 000003A4         ;  } while ((String[Length-1] != NULL)
  861 000003A4         ;           && Length < Capacity) {
  862 000003A4         LengthStringSBDone
  863 000003A4 BC08            POP              {R3}
  864 000003A6 4770            BX               LR



ARM Macro Assembler    Page 21 CMPE 250 Lab 09


  865 000003A8         ;-------------------------------------------------------
                       --------
  866 000003A8         PutChar
  867 000003A8         ;*******************************************************
                       ***************
  868 000003A8         ;Put character:
  869 000003A8         ;Adds a character to the transmit queue.
  870 000003A8         ;Input:  R0: Character to send
  871 000003A8         ;Modifies:  PSR
  872 000003A8         ;-------------------------------------------------------
                       --------
  873 000003A8         ; Wait until transmitter is ready
  874 000003A8 B506            PUSH             {R1-R2, LR} ;Save temporary reg
                                                            isters
  875 000003AA 492E            LDR              R1, =TxQRecord ;R1 = Transmit Q
                                                            ueue address
  876 000003AC B672    PutCharLoop
                               CPSID            I
  877 000003AE F7FF FF1B       BL               Enqueue     ;Write character to
                                                             send queue
  878 000003B2 B662            CPSIE            I
  879 000003B4 D2FA            BCS              PutCharLoop
  880 000003B6 493A            LDR              R1, =UART0_BASE ;Enable TIE
  881 000003B8 22AC            MOVS             R2, #UART0_C2_TI_RI
  882 000003BA 70CA            STRB             R2, [R1, #UART0_C2_OFFSET]
  883 000003BC BD06            POP              {R1-R2, PC} ;Restore R1
  884 000003BE 4770            BX               LR          ;Return
  885 000003C0         ;-------------------------------------------------------
                       --------
  886 000003C0         PutCRLF
  887 000003C0         ;*******************************************************
                       ***************
  888 000003C0         ;Put carriage return and line feed:
  889 000003C0         ;Transmits new line sequence using PutChar.
  890 000003C0         ;Calls:  PutChar
  891 000003C0         ;Modifies:  PSR
  892 000003C0         ;-------------------------------------------------------
                       --------
  893 000003C0         ;Provided to Ari Sanders
  894 000003C0         ;R. W. Melton
  895 000003C0         ;October 23, 2015
  896 000003C0         ;*******************************************************
                       ***************
  897 000003C0 B501            PUSH             {R0,LR}     ;Save registers
  898 000003C2 200D            MOVS             R0,#CR      ;Send CR
  899 000003C4 F7FF FFF0       BL               PutChar     ;Call PutChar
  900 000003C8 200A            MOVS             R0,#LF      ;Send LF
  901 000003CA F7FF FFED       BL               PutChar     ;Call PutChar
  902 000003CE BD01            POP              {R0,PC}     ;Restore registers
  903 000003D0         ;-------------------------------------------------------
                       --------
  904 000003D0         PutNumHex
  905 000003D0         ;*******************************************************
                       ***************
  906 000003D0         ;Prints hex representation of unsigned word number in R0
                       .
  907 000003D0         ;Input:   R0:  Unsigned word value
  908 000003D0         ;Modify:  PSR
  909 000003D0         ;-------------------------------------------------------



ARM Macro Assembler    Page 22 CMPE 250 Lab 09


                       --------
  910 000003D0         ;Provided to Ari Sanders
  911 000003D0         ;R. W. Melton
  912 000003D0         ;October 23, 2015
  913 000003D0         ;*******************************************************
                       ***************
  914 000003D0         ;Save temp. registers
  915 000003D0 B506            PUSH             {R1-R2,LR}
  916 000003D2         ;Print hex digit for each nibble, starting with most sig
                       nificant
  917 000003D2         ;hex digit count
  918 000003D2 2108            MOVS             R1,#(WORD_SIZE * BYTE_BITS / NI
BBLE_BITS)
  919 000003D4         ;shift amount for most sig. nibble
  920 000003D4 221C            MOVS             R2,#((WORD_SIZE * BYTE_BITS) - 
NIBBLE_BITS)
  921 000003D6         ;mask for least significant nibble 
  922 000003D6         PutNumHexLoop                        ;repeat {
  923 000003D6 41D0            RORS             R0,R0,R2    ;  move most signif
                                                            icant nibble to lea
                                                            st
  924 000003D8 F000 F80C       BL               PutNumHexN  ;  print least sign
                                                            ificant nibble
  925 000003DC 1E49            SUBS             R1,R1,#1    ;} until ((hex digi
                                                            t count--) == 0)
  926 000003DE D1FA            BNE              PutNumHexLoop
  927 000003E0         ; Restore temp. registers
  928 000003E0 BD06            POP              {R1-R2,PC}
  929 000003E2         ;-------------------------------------------------------
                       --------
  930 000003E2         PutNumHexB
  931 000003E2         ;*******************************************************
                       ***************
  932 000003E2         ;Prints hex representation of unsigned least byte in R0.
                       
  933 000003E2         ;Input:   R0:  Unsigned byte value
  934 000003E2         ;Modify:  PSR
  935 000003E2         ;-------------------------------------------------------
                       --------
  936 000003E2         ;Provided to Ari Sanders
  937 000003E2         ;R. W. Melton
  938 000003E2         ;October 23, 2015
  939 000003E2         ;*******************************************************
                       ***************
  940 000003E2         ;Save temp. registers
  941 000003E2 B502            PUSH             {R1,LR}
  942 000003E4         ;Print hex digit for each nibble, starting with most sig
                       nificant
  943 000003E4 4601            MOV              R1,R0       ;preserve original 
                                                            byte
  944 000003E6         ;print nibble 1
  945 000003E6 0900            LSRS             R0,R0,#NIBBLE_BITS
  946 000003E8 F000 F804       BL               PutNumHexN  ;print nibble 1
  947 000003EC 4608            MOV              R0,R1       ;restore original b
                                                            yte
  948 000003EE F000 F801       BL               PutNumHexN  ;print nibble 0
  949 000003F2 BD02            POP              {R1,PC}
  950 000003F4         ;-------------------------------------------------------
                       --------



ARM Macro Assembler    Page 23 CMPE 250 Lab 09


  951 000003F4         PutNumHexN
  952 000003F4         ;*******************************************************
                       ***************
  953 000003F4         ;Prints hex representation of unsigned least nibble in R
                       0.
  954 000003F4         ;Input:   R0:  Unsigned nibble value
  955 000003F4         ;Modify:  PSR
  956 000003F4         ;-------------------------------------------------------
                       --------
  957 000003F4         ;Provided to Ari Sanders
  958 000003F4         ;R. W. Melton
  959 000003F4         ;October 23, 2015
  960 000003F4         ;*******************************************************
                       ***************
  961 000003F4         ;Save temp. registers
  962 000003F4 B503            PUSH             {R0-R1,LR}
  963 000003F6         ;Print hex digit of least significant nibble
  964 000003F6 210F            MOVS             R1,#NIBBLE_MASK
  965 000003F8 4008            ANDS             R0,R0,R1    ;value of nibble 1
  966 000003FA 3030            ADDS             R0,R0,#'0'  ;ASCII of digit in 
                                                            [0,9]
  968 000003FC         PutNumHexNAdj
                               HEXA             R0          ;ASCII of digit in 
                                                            [A,F]
  223 000003FC         ;*******************************************************
                       ***************
  224 000003FC         ;Adjusts ASCII character in $Char for correct value on [
                       'A','F'] if 
  225 000003FC         ;character is more than '9'.
  226 000003FC         ;Input:   $Char:  Character to adjust for hex digit
  227 000003FC         ;Output:  $Char:  Adjusted hex digit
  228 000003FC         ;Modify:  PSR,$Char
  229 000003FC         ;-------------------------------------------------------
                       --------
  230 000003FC         ;Provided to Ari Sanders
  231 000003FC         ;R. W. Melton
  232 000003FC         ;October 23, 2015
  233 000003FC         ;*******************************************************
                       ***************
  234 000003FC 2839            CMP              R0,#'9'     ;if (Digit
  235 000003FE D901            BLS              PutNumHexNAdjOK 
                                                            ;         > '9') {
  236 00000400         ;  map to ['A','F']
  237 00000400 3041            ADDS             R0,R0,#'A'
  238 00000402 383A            SUBS             R0,R0,#('9' + 1)
  239 00000404         PutNumHexNAdjOK                      ;}
  969 00000404 F7FF FFD0       BL               PutChar     ;print digit
  970 00000408         ; Restore temp. registers
  971 00000408 4608            MOV              R0,R1
  972 0000040A BD03            POP              {R0-R1,PC}
  973 0000040C         ;-------------------------------------------------------
                       --------
  974 0000040C         PutNumU
  975 0000040C         ;*******************************************************
                       ***************
  976 0000040C         ;Put number unsigned
  977 0000040C         ;Prints unsigned number in R0 using a minimum number of 
                       characters
  978 0000040C         ;using PutChar



ARM Macro Assembler    Page 24 CMPE 250 Lab 09


  979 0000040C         ;Calls:  DIVU
  980 0000040C         ;        PutChar
  981 0000040C         ;Input:  R0:  Unsigned value
  982 0000040C         ;Modify:  PSR
  983 0000040C         ;-------------------------------------------------------
                       --------
  984 0000040C         ;Provided to Ari Sanders
  985 0000040C         ;R. W. Melton
  986 0000040C         ;October 23, 2015
  987 0000040C         ;*******************************************************
                       ***************
  988 0000040C B503            PUSH             {R0-R1,LR}
  989 0000040E         ;Create null-terminated string on stack
  990 0000040E         ;MSB will be at TOS when done
  991 0000040E 2100            MOVS             R1,#NULL    ;Push NULL
  992 00000410 B402            PUSH             {R1}
  993 00000412         PutNumURepeat                        ;repeat {
  994 00000412         ;DIVU:  R0 rem R1 = R1 / R0
  995 00000412 4601            MOV              R1,R0       ;  Put dividend in 
                                                            R1
  996 00000414 200A            MOVS             R0,#10      ;  Divisor is 10
  997 00000416 F7FF FEB0       BL               DIVU        ;  Divide number by
                                                             10
  998 0000041A 3130            ADDS             R1,#'0'     ;  Convert digit va
                                                            lue to digit charac
                                                            ter
  999 0000041C B402            PUSH             {R1}        ;  Push next least 
                                                            digit character
 1000 0000041E 2800            CMP              R0,#0       ;} until (remaining
                                                             value == 0)
 1001 00000420 D1F7            BNE              PutNumURepeat
 1002 00000422         PutNumUWhile
 1003 00000422 BC01            POP              {R0}        ;while (TOS charact
                                                            er != NULL) {
 1004 00000424 2800            CMP              R0,#NULL
 1005 00000426 D002            BEQ              PutNumUDone
 1006 00000428 F7FF FFBE       BL               PutChar     ;  print digit
 1007 0000042C E7F9            B                PutNumUWhile
 1008 0000042E         ;}
 1009 0000042E BD03    PutNumUDone
                               POP              {R0-R1,PC}
 1010 00000430         ;-------------------------------------------------------
                       --------
 1011 00000430         PutNumUB
 1012 00000430         ;*******************************************************
                       ***************
 1013 00000430         ;Prints unsigned byte number in R0 using a minimum numbe
                       r of characters
 1014 00000430         ;Calls:  PutNumU
 1015 00000430         ;Input:  R0:  Unsigned byte value
 1016 00000430         ;Modify:  PSR
 1017 00000430         ;-------------------------------------------------------
                       --------
 1018 00000430         ;Provided to Ari Sanders
 1019 00000430         ;R. W. Melton
 1020 00000430         ;October 23, 2015
 1021 00000430         ;*******************************************************
                       ***************
 1022 00000430         ;Save registers modified



ARM Macro Assembler    Page 25 CMPE 250 Lab 09


 1023 00000430 B503            PUSH             {R0-R1,LR}
 1024 00000432         ;Mask off byte value from R0
 1025 00000432 21FF            MOVS             R1,#BYTE_MASK
 1026 00000434 4008            ANDS             R0,R0,R1
 1027 00000436         ;Print number
 1028 00000436 F7FF FFE9       BL               PutNumU
 1029 0000043A         ;Restore registers modified
 1030 0000043A         PutNumUBDone
 1031 0000043A BD03            POP              {R0-R1,PC}
 1032 0000043C                 ALIGN
 1033 0000043C         ;-------------------------------------------------------
                       --------
 1034 0000043C         PutStringSB
 1035 0000043C         ;*******************************************************
                       ***************
 1036 0000043C         ;Put string from secure buffer:
 1037 0000043C         ;Sends each character in null-terminated string to PutCh
                       ar.
 1038 0000043C         ;Calls:  PutChar
 1039 0000043C         ;Input:  R0: Address of string buffer
 1040 0000043C         ;        R1: Capacity of string buffer
 1041 0000043C         ;Modifies:  PSR
 1042 0000043C         ;-------------------------------------------------------
                       --------
 1043 0000043C         ;Provided to Ari Sanders
 1044 0000043C         ;R. W. Melton
 1045 0000043C         ;October 23, 2015
 1046 0000043C         ;*******************************************************
                       ***************
 1047 0000043C         ;Save registers
 1048 0000043C B507            PUSH             {R0-R2,LR}
 1049 0000043E         ;Register Map
 1050 0000043E         ;R0:  Current string character
 1051 0000043E         ;R1:  Capacity of string buffer (input parameter);
 1052 0000043E         ;     Address of first byte past string buffer
 1053 0000043E         ;R2:  Address of string buffer (from input parameter R0)
                       
 1054 0000043E 2900            CMP              R1,#0       ;if (buffer capacit
                                                            y) {
 1055 00000440 D00A            BEQ              PutStringSBDone
 1056 00000442 1809            ADDS             R1,R1,R0    ;First address past
                                                             buffer
 1057 00000444 4602            MOV              R2,R0       ;R0 needed for PutC
                                                            har parameter
 1058 00000446         PutStringSBLoop                      ;repeat {
 1059 00000446 7810            LDRB             R0,[R2,#0]  ;  CurrentChar of s
                                                            tring
 1060 00000448 2800            CMP              R0,#NULL    ;  if (CurrentChar 
                                                            != NULL) {
 1061 0000044A D005            BEQ              PutStringSBDone
 1062 0000044C F7FF FFAC       BL               PutChar     ;    Send current c
                                                            har to terminal
 1063 00000450 1C52            ADDS             R2,R2,#1    ;    CurrentCharPtr
                                                            ++
 1064 00000452 428A            CMP              R2,R1
 1065 00000454 D000            BEQ              PutStringSBDone
 1066 00000456 E7F6            B                PutStringSBLoop
 1067 00000458         ;} until ((CurrentChar == NULL)
 1068 00000458         ;         || (Past end of buffer))



ARM Macro Assembler    Page 26 CMPE 250 Lab 09


 1069 00000458         ;Restore registers
 1070 00000458         PutStringSBDone
 1071 00000458 BD07            POP              {R0-R2,PC}
 1072 0000045A         ;-------------------------------------------------------
                       --------
 1073 0000045A         ;>>>>>   end subroutine code <<<<<
 1074 0000045A 00 00           ALIGN
 1075 0000045C         ;*******************************************************
                       *********
 1076 0000045C         ;Vector Table Mapped to Address 0 at Reset
 1077 0000045C         ;Linker requires __Vectors to be exported
 1078 0000045C 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04010000 
              40048010 
              00010007 
              40048034 
              00000400 
              40048038 
              00000200 
              40049004 
              01000200 
              40049008 
              4006A000 
              E000E40C 
              000000C0 
              E000E280 
              00001000 
              E000E100 
              00000000 
              00000000 
              00000000         AREA             RESET, DATA, READONLY
 1079 00000000                 EXPORT           __Vectors
 1080 00000000                 EXPORT           __Vectors_End
 1081 00000000                 EXPORT           __Vectors_Size
 1082 00000000                 IMPORT           __initial_sp
 1083 00000000                 IMPORT           Dummy_Handler
 1084 00000000         __Vectors
 1085 00000000         ;ARM core vectors
 1086 00000000 00000000        DCD              __initial_sp ;00:end of stack
 1087 00000004 00000000        DCD              Reset_Handler ;01:reset vector
 1088 00000008 00000000        DCD              Dummy_Handler ;02:NMI
 1089 0000000C 00000000        DCD              Dummy_Handler ;03:hard fault
 1090 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
 1091 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
 1092 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
 1093 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
 1094 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
 1095 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
 1096 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
 1097 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (super
                                                            visor call)
 1098 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
 1099 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)



ARM Macro Assembler    Page 27 CMPE 250 Lab 09


 1100 00000038 00000000        DCD              Dummy_Handler ;14:PendableSrvRe
                                                            q (pendable request
                                                             
 1101 0000003C         ;   for system service)
 1102 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (syst
                                                            em tick timer)
 1103 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0
                                                             xfer complete/erro
                                                            r
 1104 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1
                                                             xfer complete/erro
                                                            r
 1105 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2
                                                             xfer complete/erro
                                                            r
 1106 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3
                                                             xfer complete/erro
                                                            r
 1107 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
 1108 00000054 00000000        DCD              Dummy_Handler ;21:command compl
                                                            ete; read collision
                                                            
 1109 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage d
                                                            etect;
 1110 0000005C         ;   low-voltage warning
 1111 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage w
                                                            akeup
 1112 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
 1113 00000064 00000000        DCD              Dummy_Handler ;25:I2C1
 1114 00000068 00000000        DCD              Dummy_Handler ;26:SPI0 (all IRQ
                                                             sources)
 1115 0000006C 00000000        DCD              Dummy_Handler ;27:SPI1 (all IRQ
                                                             sources)
 1116 00000070 00000000        DCD              UART0_ISR   ;28:UART0 (status; 
                                                            error)
 1117 00000074 00000000        DCD              Dummy_Handler ;29:UART1 (status
                                                            ; error)
 1118 00000078 00000000        DCD              Dummy_Handler ;30:UART2 (status
                                                            ; error)
 1119 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
 1120 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
 1121 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
 1122 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
 1123 0000008C 00000000        DCD              Dummy_Handler ;35:TPM2
 1124 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
 1125 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
                                                            
 1126 00000098 00000000        DCD              Dummy_Handler ;38:PIT (all IRQ 
                                                            sources)
 1127 0000009C 00000000        DCD              Dummy_Handler ;39:I2S0
 1128 000000A0 00000000        DCD              Dummy_Handler ;40:USB0
 1129 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
 1130 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
 1131 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
 1132 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
 1133 000000B4 00000000        DCD              Dummy_Handler ;45:Segment LCD
 1134 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA pin det
                                                            ect
 1135 000000BC 00000000        DCD              Dummy_Handler ;47:PORTC and POR



ARM Macro Assembler    Page 28 CMPE 250 Lab 09


                                                            TD pin detect
 1136 000000C0         __Vectors_End
 1137 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
 1138 000000C0                 ALIGN
 1139 000000C0         ;*******************************************************
                       *********
 1140 000000C0         ;Constants
 1141 000000C0                 AREA             MyConst,DATA,READONLY
 1142 00000000         ;>>>>> begin constants here <<<<<
 1143 00000000 54 79 70 
              65 20 61 
              20 71 75 
              65 75 65 
              20 63 6F 
              6D 6D 61 
              6E 64 20 
              28 64 2C 
              20 65 2C 
              20 68 2C 
              20 70 2C 
              20 73 29 
              3A 00    PromptStr
                               DCB              "Type a queue command (d, e, h,
 p, s):", 0
 1144 00000026         PromptPast
 1145 00000026 43 68 61 
              72 61 63 
              74 65 72 
              20 74 6F 
              20 65 6E 
              71 75 65 
              75 65 3A 
              00       EnqueueStr
                               DCB              "Character to enqueue:", 0
 1146 0000003C         EnqPast
 1147 0000003C 46 61 69 
              6C 75 72 
              65 3A 00 FailureStr
                               DCB              "Failure:", 0
 1148 00000045         FailPast
 1149 00000045 53 75 63 
              63 65 73 
              73 3A 00 SuccessStr
                               DCB              "Success:", 0
 1150 0000004E         SuccPast
 1151 0000004E 64 20 28 
              64 65 71 
              75 65 75 
              65 29 2C 
              20 65 20 
              28 65 6E 
              71 75 65 
              75 65 29 
              2C 20 68 
              20 28 68 
              65 6C 70 
              29 2C 20 



ARM Macro Assembler    Page 29 CMPE 250 Lab 09


              70 20 28 
              70 72 69 
              6E 74 29 
              2C 20 73 
              20 28 73 
              74 61 74 
              75 73 29 
              00       HelpStr DCB              "d (dequeue), e (enqueue), h (h
elp), p (print), s (status)", 0
 1152 00000088         HelpPast
 1153 00000088 53 74 61 
              74 75 73 
              3A 00    StatusStr
                               DCB              "Status:", 0
 1154 00000090         StatusPast
 1155 00000090 20 49 6E 
              20 3D 20 
              30 78 00 InStr   DCB              " In = 0x", 0
 1156 00000099         InPast
 1157 00000099 20 4F 75 
              74 20 3D 
              20 30 78 
              00       OutStr  DCB              " Out = 0x", 0
 1158 000000A3         OutPast
 1159 000000A3 20 4E 75 
              6D 20 3D 
              20 00    NumStr  DCB              " Num = ", 0
 1160 000000AB         NumPast
 1161 000000AB         ;>>>>>   end constants here <<<<<
 1162 000000AB 00              ALIGN
 1163 000000AC         ;*******************************************************
                       *********
 1164 000000AC         ;Variables
 1165 000000AC                 AREA             MyData,DATA,READWRITE
 1166 00000000         ;>>>>> begin variables here <<<<<
 1167 00000000 00 00 00 
              00       QBuffer SPACE            Q_BUF_SZ    ; FIFO queue buffer
                                                            
 1168 00000004                 KEEP             QBuffer
 1169 00000004                 ALIGN
 1170 00000004 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 QRecord SPACE            Q_REC_SZ    ; FIFO queue manage
                                                            ment record
 1171 00000016                 KEEP             QRecord
 1172 00000016 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 30 CMPE 250 Lab 09


              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    TxQBuffer
                               SPACE            XQ_BUF_SZ   ; Transmit queue bu
                                                            ffer
 1173 00000066                 KEEP             TxQBuffer
 1174 00000066 00 00           ALIGN
 1175 00000068 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 TxQRecord
                               SPACE            Q_REC_SZ    ; Transmit queue ma
                                                            nagement record
 1176 0000007A                 KEEP             TxQRecord
 1177 0000007A 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    RxQBuffer
                               SPACE            XQ_BUF_SZ   ; Receive queue buf
                                                            fer
 1178 000000CA                 KEEP             RxQBuffer



ARM Macro Assembler    Page 31 CMPE 250 Lab 09


 1179 000000CA 00 00           ALIGN
 1180 000000CC 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 RxQRecord
                               SPACE            Q_REC_SZ    ; Receive queue man
                                                            agement record
 1181 000000DE                 KEEP             RxQRecord
 1182 000000DE         ;>>>>>   end variables here <<<<<
 1183 000000DE                 END
Command Line: --debug --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --
depend=.\lab09.d -o.\lab09.o -I"C:\Users\sande_000\Documents\RIT\Fall 2015\CMPE
-250\Lab09\RTE" -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.7.0\Device\Includ
e -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__EVAL SETA 1" --predefine="__UVI
SION_VERSION SETA 516" --predefine="MKL46Z256xxx4 SETA 1" --list=.\lab09.lst la
b09.s
